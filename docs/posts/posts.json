[
  {
    "path": "posts/2021-11-14-r-bootcamp-2-reading-writing-and-manipulating-data/",
    "title": "R Bootcamp #2: Reading, Writing, and Manipulating Data",
    "description": "Using base R to perform common operations on external data",
    "author": [
      {
        "name": "Derek Holliday",
        "url": {}
      }
    ],
    "date": "2021-11-14",
    "categories": [
      "bootcamp"
    ],
    "contents": "\r\n\r\nContents\r\nVideo Summary\r\nGetting Data into R\r\nReading local files\r\nWorking directories\r\nFile types\r\n\r\nReading non-local files\r\n\r\nManipulating Data\r\nGetting to know your data\r\nExploring the data\r\nRecoding\r\nifelse()\r\nReverse Coding\r\nScales\r\n\r\n\r\nWriting Data\r\nTest your knowledge\r\n\r\nWelcome back! In this post, I’ll cover some common operations done while manipulating data in R using base R functions.\r\nVideo Summary\r\n\r\n\r\nGetting Data into R\r\nIn the last tutorial, we discussed one way pre-made data can be loaded into R: through packages. For non-toy examples, though, you will typically need to “read” data from an external file or site into your R environment in order to manipulate it. There are many ways to do this, and we’ll cover a few below.\r\nReading local files\r\nTypically, you will want to read files into R that already exist on your local computer. To do this, you need to know two things: where the file is located and what type of file it is.\r\nWorking directories\r\nRegarding file location, you will greatly benefit from keeping a consistent file organization system. One of the most worthwhile investments in grad school will be cloud storage. You should be able to completely destroy your computer and be back up and running with your files overnight. Typically, I keep one Dropbox folder per project with subfolders for data, code, writing, etc.\r\nBy default, R looks for and saves file in the working directory of the current R session. To see the current working directory for your session, enter the function getwd(). If you want to change your working directory, you can do so manually by entering the folder path in setwd(). For example, say I have a file I want to read in from the “r_maven” folder in my Dropbox. Given my own file pathing, my command may look like:\r\n\r\n\r\nsetwd(\"C:/Users/username/Dropbox/r_maven\") # Windows\r\nsetwd(\"/Users/username/Dropbox/r_maven\") # Mac\r\n\r\n\r\n\r\nYou can also set your working directory through RStudio using Session > Set Working Directory > Choose Directory. Selecting “Source file location” will set the working directory to where the current script is saved. You can also set the default working directory from Tools > Global Options. After that, you can use a period to reference your default directory in the file path. For example, if my default directory is set to “C:/Users/username”, I could access the same folder as above using:\r\n\r\n\r\nsetwd(\"./Dropbox/r_maven\")\r\n\r\n\r\n\r\nThese are the “classic” ways of setting the working directory, but modern alternatives exist. For example, you’ll notice I’m using what’s called an R Project, which automatically sets the working directory to the project folder. This is particularly useful when collaborating or using Github. You can learn more about R Projects here, but for now we’ll consider it a more advanced topic.\r\nFile types\r\nNow that we’ve set our working directory, we need to actually read in the data. There are many types of files you might work with, but the most common is a “.csv” file, which stands for “comma separated values.” R has a built-in function read.csv() for reading files like this. Assuming your file is located in your working directory, the following will read in the data and assign it to the object dat:\r\n\r\n\r\ndat = read.csv(\"filename.csv\")\r\n\r\n\r\n\r\nIf you check ?read.csv, you’ll notice the function returns a dataframe, so we can treat dat appropriately. Alternatively, many now prefer the read_csv() function from the readr package, which is documented to be significantly faster than base R’s read.csv().\r\nWhat if your data is saved as something other than a .csv file, though? You can find a solution for pretty much any file type. For Stata/SAS/SPSS files, I suggest functions from haven, such as read_dta(), read_sas(), and read_spss(). If you need data from a non-csv Excel file, the readxl and xlsx packages will be useful. For those with massive data files, fread() from data.table will be your best friend.\r\nReading non-local files\r\nSometimes we want to read files we haven’t downloaded locally, which is especially useful if we need to save space on our local drive. One way to read non-local files is simply using the appropriate read function with the link to the appropriate file.\r\nFor example, the New York Times datasets of COVID-19 cases and deaths. Looking at their documentation, I figure out the link for their nationally-aggregated results. I can read that file in below:\r\n\r\n\r\nnyt_cov = read.csv(\"https://raw.githubusercontent.com/nytimes/covid-19-data/master/us.csv\")\r\nhead(nyt_cov) # Print first 6 rows\r\n\r\n\r\n        date cases deaths\r\n1 2020-01-21     1      0\r\n2 2020-01-22     1      0\r\n3 2020-01-23     1      0\r\n4 2020-01-24     2      0\r\n5 2020-01-25     3      0\r\n6 2020-01-26     5      0\r\n\r\nAnother common way of getting data is querying an API. This is a fairly advanced topic, but I want you to know it’s an option. For example, King County, WA has a really well organized repository of precinct-level election results. I can get those results into an R-friendly format with the following:\r\n\r\n\r\n# The following two packages are necessary for API querying\r\nlibrary(httr)\r\nlibrary(jsonlite)\r\n\r\nres = GET(\"https://data.kingcounty.gov/resource/2824-fjrn.json\") # Save result of query to res\r\nking_wa = fromJSON(rawToChar(res$content)) # clean content and convert to dataframe\r\n\r\nhead(king_wa)\r\n\r\n\r\n     precinct                                     race leg cc cg\r\n1 SHL 32-0001 State of Washington Advisory Vote No. 32  32  1  7\r\n2 SHL 32-0001 State of Washington Advisory Vote No. 32  32  1  7\r\n3 SHL 32-0001 State of Washington Advisory Vote No. 32  32  1  7\r\n4 SHL 32-0001 State of Washington Advisory Vote No. 32  32  1  7\r\n5 SHL 32-0001 State of Washington Advisory Vote No. 32  32  1  7\r\n6 SHL 32-0001 State of Washington Advisory Vote No. 32  32  1  7\r\n  countergroup party       countertype sumofcount\r\n1        Total    NP Registered Voters        566\r\n2        Total    NP     Times Counted        418\r\n3        Total    NP Times Under Voted         42\r\n4        Total  <NA>          Repealed        182\r\n5        Total  <NA>        Maintained        194\r\n6        Total    NP  Times Over Voted          0\r\n\r\nAgain, there’s more going on here than we’re going to cover, such as the rawToChar() function and the fact that this API has a default limit of 1000 results returned per query, but you should know it exists as an option. Note we don’t need to set a working directory for external files.\r\nManipulating Data\r\nFor the next section, we’ll be using data from the 2016 ANES pilot, provided by Tyler Reny. Let’s read that into our environment now:\r\n\r\n\r\ndf = foreign::read.dta(\"http://tylerreny.github.io/data/anes_pilot_2016.dta\",\r\n                       convert.factors = F)\r\n\r\n\r\n\r\nNotice my use of foreign:: before the function we want to call. In some instances, you may want to use a function from a package without loading the entire package. The package-double colon-function syntax allows you to do that.\r\nGetting to know your data\r\nDownloading data sight unseen tends to mean we don’t know much about what’s inside. R has a few functions to help do so that you’ve already seen, such as:\r\n\r\n\r\ndim(df)\r\n\r\n\r\n[1] 1200  598\r\n\r\nYikes, that’s 1200 observations of 598 variables. Because of that, I’m not going to show the output of the functions below, since I’d be printing 598 lines (but see the video). Instead, know that names() returns a character vector of all the variable names in the dataframe. glimpse() from the dplyr package gives slightly more detail, giving you the variable names, the types of the variables, and the first few values.\r\n\r\n\r\nnames(df)\r\ndplyr::glimpse(df)\r\n\r\n\r\n\r\nExploring the data\r\nMost data, especially survey data, will come with a codebook to help guide your through how to interpret values associated with each variable. The code book for this particular dataset can be found here. For this exercise, we’ll focus on cleaning the demographic variables, which we can find in this chunk:\r\n\r\n\r\nnames(df)[218:238]\r\n\r\n\r\n [1] \"birthyr\"       \"gender\"        \"race\"          \"race_other\"   \r\n [5] \"educ\"          \"marstat\"       \"speakspanish\"  \"employ\"       \r\n [9] \"employ_t\"      \"faminc\"        \"faminc2\"       \"state\"        \r\n[13] \"votereg\"       \"pid3\"          \"pid7\"          \"ideo5\"        \r\n[17] \"newsint\"       \"pew_bornagain\" \"pew_churatd\"   \"religpew\"     \r\n[21] \"religpew_t\"   \r\n\r\nIf we want to dive into one particular variable, we can do so using head() and the variable selection syntax dataframe-dollar sign-variable:\r\n\r\n\r\nhead(df$birthyr)\r\n\r\n\r\n[1] 1995 1950 1973 1980 1978 1957\r\n\r\nLooks numeric, but we can confirm with class()\r\n\r\n\r\nclass(df$birthyr)\r\n\r\n\r\n[1] \"numeric\"\r\n\r\nWe can also use the table function to see how many times each year is in the data:\r\n\r\n\r\ntable(df$birthyr)\r\n\r\n\r\n\r\n1921 1924 1925 1926 1927 1930 1931 1932 1933 1934 1935 1936 1937 1938 \r\n   1    1    2    1    1    1    2    3    4    2    1    9    7   10 \r\n1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 \r\n   6   12    8   10   14    8   16   12   16    9   16   18   20   24 \r\n1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 \r\n  28   38   31   34   27   23   26   26   29   21   17   22   17    9 \r\n1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 \r\n  14   18    8   13   10   24   34   20   24   21   25   26   16   24 \r\n1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 \r\n  20   22   19   18   17   21   22   24   27   26   20   22   19   20 \r\n1995 1996 1997 \r\n  13   17   14 \r\n\r\nsort(table(df$birthyr)) #Sort by number\r\n\r\n\r\n\r\n1921 1924 1926 1927 1930 1935 1925 1931 1934 1932 1933 1939 1937 1941 \r\n   1    1    1    1    1    1    2    2    2    3    4    6    7    8 \r\n1944 1969 1936 1948 1966 1938 1942 1971 1940 1946 1970 1995 1943 1967 \r\n   8    8    9    9    9   10   10   10   12   12   13   13   14   14 \r\n1997 1945 1947 1949 1979 1963 1965 1985 1996 1950 1968 1984 1983 1993 \r\n  14   16   16   16   16   17   17   17   17   18   18   18   19   19 \r\n1951 1974 1981 1991 1994 1962 1976 1986 1964 1982 1987 1992 1958 1952 \r\n  20   20   20   20   20   21   21   21   22   22   22   22   23   24 \r\n1972 1975 1980 1988 1977 1959 1960 1978 1990 1957 1989 1953 1961 1955 \r\n  24   24   24   24   25   26   26   26   26   27   27   28   29   31 \r\n1956 1973 1954 \r\n  34   34   38 \r\n\r\nYou can also look at a histogram to see how the years are distributed.\r\n\r\n\r\nhist(df$birthyr)\r\n\r\n\r\n\r\n\r\nThis is great, but say I want to create an age variable instead. To do that, we need to create a new variable, subtracting birth year from 2016 (since that’s when the survey was conducted):\r\n\r\n\r\ndf$age = 2016 - df$birthyr\r\n\r\n\r\n\r\nYou can check the new variable was created by looking at the name of the last variable in the dataset, where R puts new variables by default:\r\n\r\n\r\nnames(df)[ncol(df)]\r\n\r\n\r\n[1] \"age\"\r\n\r\nAnd we can look at a few properties of our newly created variable using a few functions you know and a few that are new:\r\n\r\n\r\nhist(df$age)\r\n\r\n\r\n\r\ntable(df$age)\r\nrange(df$age) # Min and Max values\r\nmean(df$age) # Average/Mean\r\nmedian(df$age) # Median\r\n\r\n\r\n\r\n19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \r\n14 17 13 20 19 22 20 26 27 24 22 21 17 18 19 22 20 24 16 26 25 21 24 \r\n42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 \r\n20 34 24 10 13  8 18 14  9 17 22 17 21 29 26 26 23 27 34 31 38 28 24 \r\n65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 89 \r\n20 18 16  9 16 12 16  8 14 10  8 12  6 10  7  9  1  2  4  3  2  1  1 \r\n90 91 92 95 \r\n 1  2  1  1 \r\n[1] 19 95\r\n[1] 48.0625\r\n[1] 48\r\n\r\nOne of the nice things about this age variable is that there is no missing data (otherwise our mean/median functions would have returned an error). If you ever want to check for the prevalence of NA values, you can use is.na() (which returns a boolean vector the same length as the vector given to the function) in conjunction with a few other functions. Let’s do that using the ftobama variable, a feeling thermometer for President Obama, which I know has some NAs:\r\n\r\n\r\nany(is.na(df$ftobama)) # Are there ANY NA values in this vector?\r\n\r\n\r\n[1] TRUE\r\n\r\ntable(is.na(df$ftobama)) # How many?\r\n\r\n\r\n\r\nFALSE  TRUE \r\n 1198     2 \r\n\r\nwhich(is.na(df$ftobama)) # Where are there?\r\n\r\n\r\n[1]  62 742\r\n\r\nSo we know there are NA values in observations 62 and 742. We can check that using vector subsetting:\r\n\r\n\r\ndf$ftobama[61:63]\r\n\r\n\r\n[1] 88 NA 89\r\n\r\nRecoding\r\nSometimes survey data needs to be recoded to reflect the values we are interested. Let’s look at the distribution of the family income variable:\r\n\r\n\r\ntable(df$faminc)\r\n\r\n\r\n\r\n  1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  31 \r\n 75 122 149 128 105  99  64  77  83  50  46  29  11   5   5   3   2 \r\n 97  98 \r\n146   1 \r\n\r\nSo there seems to be a bunch of values 1-16, but then 31? What about 97 and 98? Typically numbers like these reflect missing values in the data, but check the codebook to make sure. This is indeed the case for these values, so we want to recode them to reflect that. Look what would happen if we just took these values to be normal numeric values:\r\n\r\n\r\nmean(df$faminc)\r\n\r\n\r\n[1] 16.85\r\n\r\nhist(df$faminc)\r\n\r\n\r\n\r\n\r\nR is assuming these are just part of the continuous spectrum of values for faminc, which we know shouldn’t be the case, and it skews our summary statistics. Let’s create a new variable and recode it properly, overwriting the troublesome numbers with NA:\r\n\r\n\r\ndf$income_family = df$faminc # Create new variable\r\n\r\n# Overwrite values\r\ndf$income_family[df$income_family == 31] = NA\r\ndf$income_family[df$income_family == 97] = NA\r\ndf$income_family[df$income_family == 98] = NA\r\n\r\n# Check distribution\r\nhist(df$income_family)\r\n\r\n\r\n\r\n\r\n# Check mean (notice na.rm = T)\r\nmean(df$income_family, na.rm=T)\r\n\r\n\r\n[1] 5.611798\r\n\r\nThat’s better! What exactly is the code above doing when we overwrite the values? Remember our vector subsetting and assignment operators… we take the vector df$income_family, subset to the cases where the value is equal to a certain number, then assign NA to those cases.\r\nAlternatively, we can do this all in one step using the %in% operator:\r\n\r\n\r\ndf$income_family[df$income_family %in% c(31, 97, 98)] = NA\r\n\r\n\r\n\r\nYou can also write a function if you are going to use it a lot. This is way more complex than you need to know right now, but it’s an introduction to what functions do.\r\n\r\n\r\nrecode_missing = function(var_name, missing_vals){ # arguments the function takes\r\n  var_name[var_name %in% missing_vals] = NA # recode missing values\r\n  return(var_name) # return the new variable\r\n}\r\ndf$income_family = recode_missing(df$income_family, c(31, 97, 98)) \r\n\r\n\r\n\r\nifelse()\r\nNow we want to recode race, which is currently a single variable with discrete values for different racial groups, into a series of dummy variables (0/1) for each racial group. This can be achieved using ifelse(), which takes three arguments: test, yes, and no (in that order). Test is a logical test, yes is the value returned if the test is TRUE, and no is the value returned if the test is FALSE.\r\n\r\n\r\ndf$white <- ifelse(df$race == 1, 1, 0)\r\ntable(df$white) #always check your recoding afterwards against codebook\r\n\r\n\r\n\r\n  0   1 \r\n325 875 \r\n\r\ndf$black    <- ifelse(df$race == 2, 1, 0)\r\ndf$hispanic <- ifelse(df$race == 3, 1, 0)\r\ndf$asian    <- ifelse(df$race == 4, 1, 0)\r\n\r\n\r\n\r\nYou can chain multiple logic tests into your ifelse() statements. For example, if I wanted to create a dummy variable for white men, I could do the following:\r\n\r\n\r\ndf$white_man = ifelse(df$race == 1 & df$gender == 2, 1, 0)\r\n\r\n\r\n\r\nNote that for observations with NA values, ifelse() willl return NA instead of 1 or 0. Usually that’s fine.\r\nReverse Coding\r\nPartisanship is usually measured using a 7 point scale, which is the case for the pid7 variable. Let’s first check on NAs:\r\n\r\n\r\ntable(is.na(df$pid7))\r\n\r\n\r\n\r\nFALSE  TRUE \r\n 1145    55 \r\n\r\nLooks like we’ll have to get rid of those. One thing I have trouble with in the pid7 scale is whether 7 is strong Republican or strong Democrat. I’ll recode the data and come back to it months later and forget. So, I suggest renaming it by the direction of the scale. So if 7 is strong Republican, name the variable republican_pid7 or just republican and vice versa.\r\n\r\n\r\ndf$republican_pid7 = df$pid7\r\n\r\n\r\n\r\nI usually code all my variables in similar directions. If interested in exploring the effects of racial resentment on vote or attitudes towards Obama, for example, we would want the high values on the racial resentment scale to be more racially resentful, pid7 to be recoded with Republican as the high category, and ideology to be recoded so very conservative is the largest value. When you are looking at a regression, you will see that all are positive. Otherwise you have to remember how each is coded. This way is easier.\r\nYou will have to reverse code things all the time. Here is an easy way to do it.\r\n\r\n\r\ndf$democrat_pid7 = abs(df$pid7 - 8) #reverse code\r\n\r\n#step 1. How many unique values in the scale? Add one\r\nlength(table(df$pid7)) + 1 #this would be a more general form of that\r\n\r\n\r\n[1] 8\r\n\r\n#step 2. Double check that the new scale is, indeed, a mirror image of the old scale\r\ntable(dem7 = df$democrat_pid7, rep7 = df$republican_pid7)\r\n\r\n\r\n    rep7\r\ndem7   1   2   3   4   5   6   7\r\n   1   0   0   0   0   0   0 158\r\n   2   0   0   0   0   0 116   0\r\n   3   0   0   0   0 111   0   0\r\n   4   0   0   0 205   0   0   0\r\n   5   0   0 109   0   0   0   0\r\n   6   0 146   0   0   0   0   0\r\n   7 300   0   0   0   0   0   0\r\n\r\nYou can also write this trick into a function! But always double check that things were recoded correctly!\r\n\r\n\r\nreverse_code <- function(x){\r\n  vals <- length(table(x)) + 1\r\n  abs(x - vals)\r\n}\r\ndf$democrat_pid7 <- reverse_code(df$pid7)\r\n\r\n\r\n\r\nScales\r\nFinally, we want to create a racial resentment scale. Go back to the codebook and find rr1 through rr4. This is the racial resentment battery. You’ll notice that they are all likert scale questions coded from 1 to 5 with different values for missing data. Some are reverse coded so that most resentful is a higher value and some so that least resentful is a higher value. What you have to do is look at each one, check for missing data, see if you need to flip ordering of values or not to be consistent, and then combine them all into a scale by adding them together.\r\n\r\n\r\n# Special favors\r\ntable(df$rr1)\r\n\r\n\r\n\r\n  1   2   3   4   5   8 \r\n480 247 204 118 148   3 \r\n\r\ndf$rr1rc <- recode_missing(df$rr1, 8) #recode missing\r\ndf$rr1rc <- reverse_code(df$rr1rc) #reverse code\r\ntable(df$rr1rc)\r\n\r\n\r\n\r\n  1   2   3   4   5 \r\n148 118 204 247 480 \r\n\r\n\r\n# Work way out\r\ntable(df$rr2)\r\n\r\n\r\n\r\n  1   2   3   4   5   8 \r\n213 243 196 200 345   3 \r\n\r\ndf$rr2rc <- recode_missing(df$rr2, 8) #recode missing\r\ntable(df$rr2rc)\r\n\r\n\r\n\r\n  1   2   3   4   5 \r\n213 243 196 200 345 \r\n\r\n\r\n# Less than deserve\r\ntable(df$rr3)\r\n\r\n\r\n\r\n  1   2   3   4   5   8 \r\n165 178 315 212 327   3 \r\n\r\ndf$rr3rc <- recode_missing(df$rr3, 8) #recode missing\r\ntable(df$rr3rc)\r\n\r\n\r\n\r\n  1   2   3   4   5 \r\n165 178 315 212 327 \r\n\r\n\r\n# Try harder\r\ntable(df$rr4)\r\n\r\n\r\n\r\n  1   2   3   4   5   8 \r\n270 274 301 144 209   2 \r\n\r\ndf$rr4rc <- recode_missing(df$rr4, 8) #recode missing\r\ndf$rr4rc <- reverse_code(df$rr4rc) #reverse code\r\ntable(df$rr4rc)\r\n\r\n\r\n\r\n  1   2   3   4   5 \r\n209 144 301 274 270 \r\n\r\n\r\n#check correlation to ensure they are coded properly\r\n#if you have negative numbers, you miscoded one\r\ncor(cbind(df$rr1rc,df$rr2rc,df$rr3rc,df$rr4rc), use='complete.obs')\r\n\r\n\r\n          [,1]      [,2]      [,3]      [,4]\r\n[1,] 1.0000000 0.6242036 0.6071225 0.7349020\r\n[2,] 0.6242036 1.0000000 0.7642206 0.5554276\r\n[3,] 0.6071225 0.7642206 1.0000000 0.5444361\r\n[4,] 0.7349020 0.5554276 0.5444361 1.0000000\r\n\r\n\r\n#combine into scale (ask yourself why this math works)\r\ndf$rr_scale <- ((df$rr1rc + df$rr2rc + df$rr3rc + df$rr4rc) - 4)/16\r\nhist(df$rr_scale)\r\n\r\n\r\n\r\nrange(df$rr_scale, na.rm=T)\r\n\r\n\r\n[1] 0 1\r\n\r\nWriting Data\r\nSo far we’ve created new variables for age, income, and race. There is so much more we could do here… recode gender to be a 0/1 indicator for female, reverse code ideology, etc. We’ve done quite a bit, though, so we should save our changes by writing this file to a new csv that we can load later.\r\nThe process of writing to csv is very similar to that of reading in data. By default, the file will be written to your working directoy. If you want to write it elsewhere, just specify it in the path argument:\r\n\r\n\r\nwrite.csv(df, file = \"C:/Users/myname/Dropbox/r_maven/cleaned_anes.csv\")\r\n\r\n\r\n\r\nTest your knowledge\r\nFollow THIS LINK for a quick interactive knowledge check.\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-11-14-r-bootcamp-2-reading-writing-and-manipulating-data/r-bootcamp-2-reading-writing-and-manipulating-data_files/figure-html5/unnamed-chunk-13-1.png",
    "last_modified": "2021-11-16T19:55:10-08:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-11-09-r-bootcamp-1-the-basics/",
    "title": "R Bootcamp #1: The Basics",
    "description": "An introduction to basic R functions, data types, and structures",
    "author": [
      {
        "name": "Derek Holliday",
        "url": {}
      }
    ],
    "date": "2021-11-09",
    "categories": [
      "bootcamp"
    ],
    "contents": "\r\n\r\nContents\r\nStructure and Setup\r\nVideo Summary\r\nWhat is R?\r\nBasic R Commands\r\nAssignment\r\nMath\r\nVariables\r\nVectors\r\nNaming vectors\r\nManipulating vectors\r\n\r\nMatrices: 2-dimensional arrays of data\r\nSelecting objects from a 2 dimension array\r\n\r\nDataframes\r\nLists\r\n\r\nTest your knowledge\r\nAcknowledgements\r\n\r\n\r\nWelcome to R bootcamp! Over the next few posts, we will cover basic R functionality necessary for your growth as social scientists.\r\nStructure and Setup\r\nEach tutorial will focus on one facet of R programming and can consist of a number of resources. Some will be done in video format, others more as long-form written tutorials, and some with more interactive components (or a combination of the 3). They are designed so that you can complete them in one or two sittings (think of them as a class session). Tutorials may be created by more than one Maven/TA, so you have the opportunity to see different approaches and styles. You are encouraged to reach out to us if you ever get stuck, we’re here to help!\r\nIf you haven’t already, you should install R and RStudio.\r\nVideo Summary\r\n\r\n\r\nWhat is R?\r\nR is a programming language designed for statistical computing. One of its main draws is that R is free and open source, meaning it is openly available for modification and distribution. The result is an incredibly vibrant user base active in creating new and exciting ways to use the language. It also means online help is easy to come by! R is becoming more and more popular in academia and industry for data analysis… pretty much anything you can do in Python can be done in R and vice-versa.\r\nWhile you can run R code via the built-in graphical user interface (RGui), the dominant preference is using RStudio. RStudio is an integrated development environment (IDE) that gives you all the tools needed to program. The main benefit is the ability to write and test scripts on the fly without having to enter commands one at a time.\r\nFor a more detailed summary of navigating RStudio, watch the video provided with this tutorial.\r\nBasic R Commands\r\nNow for some basic functionalities within R. If you’ve had previous experience with R or any other programming language, this should be familiar to you and you can go through this quickly.\r\nAssignment\r\nR is an object oriented programming language, meaning the basic building block when coding is some object that has an associated value.\r\nTo assign a value to a variable, we use an assignment operator. <- is the most commonly used assignment operator amongst R users, but many who come from a more programming-oriented background (myself included) use =.\r\n\r\n\r\na <- 1 # assign the variable 'a' the value of 1\r\na # print\r\n\r\n\r\n[1] 1\r\n\r\nThe first line of code above makes the assignment, and the second of just entering a asks R to give you the value of that variable. The same thing works using =:\r\n\r\n\r\nb = 2\r\nb\r\n\r\n\r\n[1] 2\r\n\r\nMath\r\nR can be used as a calculator using both numbers and the variables you assign values to. R follows PEMDAS, but () are recommended for readability.\r\n\r\n\r\n5 + 6 # addition\r\n\r\n\r\n[1] 11\r\n\r\n9 - 3 # subtraction\r\n\r\n\r\n[1] 6\r\n\r\n6 / 10 # division\r\n\r\n\r\n[1] 0.6\r\n\r\n5 * 8 # multiplication\r\n\r\n\r\n[1] 40\r\n\r\n5 ^ 2 # exponentiation\r\n\r\n\r\n[1] 25\r\n\r\nsqrt(25) # square roots, etc...\r\n\r\n\r\n[1] 5\r\n\r\nNote the different structure of sqrt(). This is a function, where 25 is the value provided to the first argument of the function. We will get into more complex functions later, but is important you understand the language behind them. Also note you can perform multiple operations at once, but remember your order of operations!\r\n\r\n\r\n5 + 3 ^ 2 / 3 - 10\r\n\r\n\r\n[1] -2\r\n\r\n(5 + 3)^2 / (3 - 10)\r\n\r\n\r\n[1] -9.142857\r\n\r\nVariables\r\nVariables are the workhorse objects of R. They store whatever you give them (what we did above with a and b).\r\nThere are many naming conventions for variables, and it tends to depend on your personal style:\r\n\r\n\r\nsome_use_snake_case\r\nothers.use.periods\r\ngoogleUsesCamelCase\r\n\r\n\r\n\r\nThis is entirely a matter of preference. I tend to use snake case because many of the base R functions use periods and shouldn’t be overwritten (such as is.matrix()), but that isn’t unique to periods (for example, the read_dta() function from the haven package).\r\nWe can now perform operations using variables:\r\n\r\n\r\nx = 10\r\ny = 15\r\nx + y\r\n\r\n\r\n[1] 25\r\n\r\nOnce a variable is stored, it is kept in your system’s global environment until overwritten or you shut down your R session. Remember the values of a and b from above?\r\n\r\n\r\na + b\r\n\r\n\r\n[1] 3\r\n\r\nVariables don’t have to be numeric. For example, we can assign a character string to x, overwriting its previous value:\r\n\r\n\r\nx = 'This is a character string'\r\nx\r\n\r\n\r\n[1] \"This is a character string\"\r\n\r\nEither single or double quotations work, just be consistent. Now that we’ve overwritten the value of x, look at what happens when we try to mix types in a function:\r\n\r\n\r\nx + y\r\n\r\n\r\nError in x + y: non-numeric argument to binary operator\r\n\r\nYou should be wary of performing operations on mixed types, as they can lead to unexpected outcomes. R is a fairly lenient language… if it can do something, it’ll do it without warning you that something might be fishy.\r\nTo check what kind of variable you have, you can use class():\r\n\r\n\r\nclass(x)\r\n\r\n\r\n[1] \"character\"\r\n\r\nclass(y)\r\n\r\n\r\n[1] \"numeric\"\r\n\r\nAnother type of variable is a boolean. These take simple TRUE/FALSE values:\r\n\r\n\r\nmy_boolean = T\r\nmy_other_boolean = FALSE\r\n\r\nmy_boolean\r\n\r\n\r\n[1] TRUE\r\n\r\nmy_other_boolean\r\n\r\n\r\n[1] FALSE\r\n\r\nYou can use the single letters T/F and the written versions TRUE/FALSE interchangeably. Just make sure to NEVER assign a value to T or F unless you want to break something.\r\nVectors\r\nSo far we’ve worked with variables with only one object in them:\r\n\r\n\r\nlength(x) # returns number of objects inside a variable\r\n\r\n\r\n[1] 1\r\n\r\nThese are called scalars and are actually fairly rare in our day-to-day work, since we tend to want to perform operations on variables holding multiple objects. These variables are called vectors:\r\n\r\n\r\nmy_vector = c(1,2,3,4,5,6)\r\nmy_vector\r\n\r\n\r\n[1] 1 2 3 4 5 6\r\n\r\nclass(my_vector)\r\n\r\n\r\n[1] \"numeric\"\r\n\r\nlength(my_vector)\r\n\r\n\r\n[1] 6\r\n\r\nNotice that c() is a function that combines or concatenates objects together. Note that all the objects in a vector need to be the same class. Let’s see what happens when we combine character and numeric objects together:\r\n\r\n\r\nvector2 = c(1,2,3,'dog')\r\nvector2\r\n\r\n\r\n[1] \"1\"   \"2\"   \"3\"   \"dog\"\r\n\r\nclass(vector2)\r\n\r\n\r\n[1] \"character\"\r\n\r\nWhat did it do to the numeric elements? Note that it will ALWAYS default to ALL characters if you have a single non-numeric item in the vector.\r\nIn sum, you can have vectors of single type scalars:\r\n\r\n\r\nmy_numeric_vector = c(1,10,20,30,50,100)\r\nmy_character_vector = c('cool','this','is','a','character','vector')\r\nmy_boolean_vector = c(T,T,T,F,F,T)\r\n\r\n\r\n\r\nNaming vectors\r\nSometimes it can be useful to assign names to objects in vectors to keep track of values associated with certain things. Let’s say I want to assign batting averages to baseball players on the Los Angeles Dodgers. I’ll create a vector of batting averages, then assign names to the averages using the names() function:\r\n\r\n\r\nbatting_average = c(.338, .306, .278, .264)\r\nnames(batting_average) = c(\"Trea Turner\", \"Corey Seager\", \"Justin Turner\", \"Mookie Betts\")\r\nbatting_average\r\n\r\n\r\n  Trea Turner  Corey Seager Justin Turner  Mookie Betts \r\n        0.338         0.306         0.278         0.264 \r\n\r\nWhat if I want to reuse those names for other vectors, but don’t want to copy and paste them every time? You can create a vector of names and use that for assignment instead:\r\n\r\n\r\ngames_played = c(52, 95, 151, 122)\r\nplayer_names = c(\"Trea Turner\", \"Corey Seager\", \"Justin Turner\", \"Mookie Betts\")\r\nnames(games_played) = player_names\r\ngames_played\r\n\r\n\r\n  Trea Turner  Corey Seager Justin Turner  Mookie Betts \r\n           52            95           151           122 \r\n\r\nManipulating vectors\r\nVectors allow for some advanced calculations:\r\n\r\n\r\na <- c(1,2,3,4,5)\r\nb <- c(1,5,2,6,3)\r\nsum(a)\r\n\r\n\r\n[1] 15\r\n\r\nsum(b)\r\n\r\n\r\n[1] 17\r\n\r\nNotice what happens when you add these together (this is unique to vector based code!):\r\n\r\n\r\na + b\r\n\r\n\r\n[1]  2  7  5 10  8\r\n\r\nThe default R behavior is to perform element-wise operations: functions are applied to elements of the same position. Note that R will still perform operations on vectors of different lengths, but give a warning message and recycle elements from the shorter vector.\r\nSome other things you can do with vectors:\r\n\r\n\r\na > b  # Greater than\r\n\r\n\r\n[1] FALSE FALSE  TRUE FALSE  TRUE\r\n\r\na < b  # Less than\r\n\r\n\r\n[1] FALSE  TRUE FALSE  TRUE FALSE\r\n\r\na >= b # Greater than or equal to\r\n\r\n\r\n[1]  TRUE FALSE  TRUE FALSE  TRUE\r\n\r\na <= b # Less than or equal to\r\n\r\n\r\n[1]  TRUE  TRUE FALSE  TRUE FALSE\r\n\r\na == b # Equal to\r\n\r\n\r\n[1]  TRUE FALSE FALSE FALSE FALSE\r\n\r\na != b # Not equal to\r\n\r\n\r\n[1] FALSE  TRUE  TRUE  TRUE  TRUE\r\n\r\nYou can also locate items within vectors using bracket operators:\r\n\r\n\r\nb[2]       # second element\r\n\r\n\r\n[1] 5\r\n\r\nb[1:3]     # elements 1 through 3\r\n\r\n\r\n[1] 1 5 2\r\n\r\nb[c(2,4)]  # elements 2 and 4\r\n\r\n\r\n[1] 5 6\r\n\r\nb[-5]      # not element 5\r\n\r\n\r\n[1] 1 5 2 6\r\n\r\nb[-(2:3)]  # not elements 2 through 3\r\n\r\n\r\n[1] 1 6 3\r\n\r\nb[-c(2,4)] # not elements 2 and 4\r\n\r\n\r\n[1] 1 2 3\r\n\r\nYou can do some pretty advanced selections, too. Let’s say you want to pull out the values of every object in a vector that is positive:\r\n\r\n\r\nvec <- c(-2,-5,-7,2,5,-3,12)\r\nvec > 0 # notice the boolean vector returned\r\n\r\n\r\n[1] FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE\r\n\r\nvec[vec == 12] # this pulls out every value that corresponds to the argument\r\n\r\n\r\n[1] 12\r\n\r\nMatrices: 2-dimensional arrays of data\r\nMoving now from single vectors of data to 2 dimensional arrays (think of spreadsheets with rows and columns!) called matrices. Note that matrices are used frequently when you are doing statistical analyses. You won’t use explicitly use them very often, at least at first, with your own data analysis but you will be using them frequently in your statistics courses.\r\nLet’s create a 2x2 empty matrix:\r\n\r\n\r\nmatrix(nrow=2,ncol=2)\r\n\r\n\r\n     [,1] [,2]\r\n[1,]   NA   NA\r\n[2,]   NA   NA\r\n\r\nAt this point we should pause to discuss functions again. matrix is a function that creates a matrix and takes a number of arguments. Here, we are just providing values for two: nrow and ncol. To see the full list of arguments take by a function and how it works, simply type ?functionName into the console to display a help menu.\r\nYou can create a matrix with specific values:\r\n\r\n\r\nmatrix(data = c(1,2,3,4),nrow=2,ncol=2)\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    1    3\r\n[2,]    2    4\r\n\r\nNotice it fills it in by column by default. You can fill it in the other way, by row:\r\n\r\n\r\nmatrix(data = c(1,2,3,4),nrow=2,ncol=2,byrow=T)\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    1    2\r\n[2,]    3    4\r\n\r\nLet’s do a bigger matrix:\r\n\r\n\r\nmatrix(1:28,nrow=4)\r\n\r\n\r\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7]\r\n[1,]    1    5    9   13   17   21   25\r\n[2,]    2    6   10   14   18   22   26\r\n[3,]    3    7   11   15   19   23   27\r\n[4,]    4    8   12   16   20   24   28\r\n\r\nNotice that I don’t need to tell it number of columns because it will calculate how many columns needed to fill in 4 rows with 28 objects. What happens if I misspecify?\r\n\r\n\r\nmyMatrix <- matrix(1:25,nrow=4)\r\nmyMatrix\r\n\r\n\r\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7]\r\n[1,]    1    5    9   13   17   21   25\r\n[2,]    2    6   10   14   18   22    1\r\n[3,]    3    7   11   15   19   23    2\r\n[4,]    4    8   12   16   20   24    3\r\n\r\nNotice that IT WILL STILL CREATE THE MATRIX but will return an error. Look at what it does to the extra values that weren’t specified. If you mess up and mis-specify the matrix and don’t pay attention, you can create grave errors this way.\r\nYou can give the matrix rownames and column names:\r\n\r\n\r\nrownames(myMatrix) <- c('row1','row2','row3','row4')\r\ncolnames(myMatrix) <- c('a','b','c','d','e','f','g')\r\nmyMatrix\r\n\r\n\r\n     a b  c  d  e  f  g\r\nrow1 1 5  9 13 17 21 25\r\nrow2 2 6 10 14 18 22  1\r\nrow3 3 7 11 15 19 23  2\r\nrow4 4 8 12 16 20 24  3\r\n\r\nYou can add rows and columns to the matrix using two useful commands rbind and cbind:\r\n\r\n\r\nrow5 <- 1:7\r\nrbind(myMatrix,row5)\r\n\r\n\r\n     a b  c  d  e  f  g\r\nrow1 1 5  9 13 17 21 25\r\nrow2 2 6 10 14 18 22  1\r\nrow3 3 7 11 15 19 23  2\r\nrow4 4 8 12 16 20 24  3\r\nrow5 1 2  3  4  5  6  7\r\n\r\nNote what happens after you add that, though:\r\n\r\n\r\nmyMatrix\r\n\r\n\r\n     a b  c  d  e  f  g\r\nrow1 1 5  9 13 17 21 25\r\nrow2 2 6 10 14 18 22  1\r\nrow3 3 7 11 15 19 23  2\r\nrow4 4 8 12 16 20 24  3\r\n\r\nIt isn’t permanently added until you save it:\r\n\r\n\r\nmyMatrix <- rbind(myMatrix,row5)\r\nmyMatrix\r\n\r\n\r\n     a b  c  d  e  f  g\r\nrow1 1 5  9 13 17 21 25\r\nrow2 2 6 10 14 18 22  1\r\nrow3 3 7 11 15 19 23  2\r\nrow4 4 8 12 16 20 24  3\r\nrow5 1 2  3  4  5  6  7\r\n\r\nLet’s add a column now:\r\n\r\n\r\nh <- c(1,2,3,4,5)\r\nmyMatrix <- cbind(myMatrix,h)\r\nmyMatrix\r\n\r\n\r\n     a b  c  d  e  f  g h\r\nrow1 1 5  9 13 17 21 25 1\r\nrow2 2 6 10 14 18 22  1 2\r\nrow3 3 7 11 15 19 23  2 3\r\nrow4 4 8 12 16 20 24  3 4\r\nrow5 1 2  3  4  5  6  7 5\r\n\r\nSelecting objects from a 2 dimension array\r\nYou can use bracket operators to select objects from a 2-dimensional array as well. You just need to specify the row and column in this format matrix[row,column]\r\n\r\n\r\nmyMatrix[1,2] # row 1, column 2\r\n\r\n\r\n[1] 5\r\n\r\nmyMatrix[1,] # return EVERYTHING in row 1\r\n\r\n\r\n a  b  c  d  e  f  g  h \r\n 1  5  9 13 17 21 25  1 \r\n\r\nmyMatrix[,2] # return EVERYTHING in column 2\r\n\r\n\r\nrow1 row2 row3 row4 row5 \r\n   5    6    7    8    2 \r\n\r\nOr you can be more advanced. Let’s select row 1 and 5 for column 2 and 4:\r\n\r\n\r\nmyMatrix[c(1,5),c(2,4)]\r\n\r\n\r\n     b  d\r\nrow1 5 13\r\nrow5 2  4\r\n\r\nOr rows 1 through 4 of columns 2 through 4:\r\n\r\n\r\nmyMatrix[1:4,2:4]\r\n\r\n\r\n     b  c  d\r\nrow1 5  9 13\r\nrow2 6 10 14\r\nrow3 7 11 15\r\nrow4 8 12 16\r\n\r\nYou can do calculations with matrices:\r\n\r\n\r\nmyMatrix * 2\r\n\r\n\r\n     a  b  c  d  e  f  g  h\r\nrow1 2 10 18 26 34 42 50  2\r\nrow2 4 12 20 28 36 44  2  4\r\nrow3 6 14 22 30 38 46  4  6\r\nrow4 8 16 24 32 40 48  6  8\r\nrow5 2  4  6  8 10 12 14 10\r\n\r\nmyMatrix / 2\r\n\r\n\r\n       a   b   c   d    e    f    g   h\r\nrow1 0.5 2.5 4.5 6.5  8.5 10.5 12.5 0.5\r\nrow2 1.0 3.0 5.0 7.0  9.0 11.0  0.5 1.0\r\nrow3 1.5 3.5 5.5 7.5  9.5 11.5  1.0 1.5\r\nrow4 2.0 4.0 6.0 8.0 10.0 12.0  1.5 2.0\r\nrow5 0.5 1.0 1.5 2.0  2.5  3.0  3.5 2.5\r\n\r\nmyMatrix * myMatrix # This is element-wise\r\n\r\n\r\n      a  b   c   d   e   f   g  h\r\nrow1  1 25  81 169 289 441 625  1\r\nrow2  4 36 100 196 324 484   1  4\r\nrow3  9 49 121 225 361 529   4  9\r\nrow4 16 64 144 256 400 576   9 16\r\nrow5  1  4   9  16  25  36  49 25\r\n\r\nt(myMatrix) # transpose\r\n\r\n\r\n  row1 row2 row3 row4 row5\r\na    1    2    3    4    1\r\nb    5    6    7    8    2\r\nc    9   10   11   12    3\r\nd   13   14   15   16    4\r\ne   17   18   19   20    5\r\nf   21   22   23   24    6\r\ng   25    1    2    3    7\r\nh    1    2    3    4    5\r\n\r\nIf you want to do actual matrix multiplication, you need to use the special matrix multiplication operator %*%\r\n\r\n\r\nmyMatrix %*% t(myMatrix)\r\n\r\n\r\n     row1 row2 row3 row4 row5\r\nrow1 1632 1099 1191 1283  481\r\nrow2 1099 1149 1224 1299  339\r\nrow3 1191 1224 1307 1390  372\r\nrow4 1283 1299 1390 1481  405\r\nrow5  481  339  372  405  165\r\n\r\nDataframes\r\nThe next format we’ll learn is the data frame. This is how you will work with data almost all of the time you are doing statistical analyses. Think again of the spreadsheet where you have rows (observations) and columns (variables). Dataframes are different than matrices because they can hold different types of data. One column can be numeric, another character, and another boolean.\r\nImportant to note here that there is a ‘tidy’ version of dataframes called tibbles, which has built-in differences for viewing and stricter subsetting functionality. You will learn more about that in future lessons.\r\nTo work with a sample dataframe let’s install the package palmerpenguins so that we can work with their toy dataset.\r\n\r\n\r\n#install.packages('palmerpenguins') if you need to\r\nlibrary(palmerpenguins) #load the package and datasets\r\n\r\n\r\n\r\nIf you ever want to know what datasets a package loads, you can use the following:\r\n\r\n\r\ndata(package = \"palmerpenguins\")\r\n\r\n\r\n\r\nIn this case, we get two dataframes: penguins and penguins_raw.\r\nThere are some helper functions in R to help you look at a dataframe. The first, which will be helpful at first but I encourage you to not use frequently is View()\r\n\r\n\r\nView(penguins)\r\n\r\n\r\n\r\nUse these instead:\r\n\r\n\r\nhead(penguins) #looks at the first 6 rows\r\ntail(penguins) #looks at last 6 rows\r\nstr(penguins) #shows what each variable is\r\nsummary(penguins) #summarises each variable\r\n\r\n\r\n\r\nHow do you create your own dataframe?\r\n\r\n\r\nmyDataFrame <- data.frame(x = rnorm(10),\r\n                          y = rnorm(10))\r\nmyDataFrame\r\n\r\n\r\n            x           y\r\n1   0.7422935  0.01915408\r\n2  -0.6393958 -1.07390674\r\n3  -0.3553513 -0.70612467\r\n4   0.9717347 -0.66081543\r\n5   0.3951876  1.54822209\r\n6   0.3399082 -1.35654867\r\n7  -0.7663295 -0.24744880\r\n8   1.4427279 -0.77805014\r\n9   1.0579099 -0.46334326\r\n10  0.1759219  0.97311272\r\n\r\nA few things are happening here. I am creating a dataframe with 2 columns, x and y. Each consists of 10 random values from a standard normal distribution, that is what the rnorm() function does. Therefore it has 10 rows. You can look at the size of the dataframe with the dim() function or count the rows and columsn with the nrow() and ncol() functions. Note that your dataframe will look different than mine becuase you will be drawing different random numbers. This is okay! For consistency, you can use set.seed()\r\n\r\n\r\ndim(myDataFrame)\r\n\r\n\r\n[1] 10  2\r\n\r\nncol(myDataFrame)\r\n\r\n\r\n[1] 2\r\n\r\nnrow(myDataFrame)\r\n\r\n\r\n[1] 10\r\n\r\nYou select elements the same way as with matrices, but there are some additional operators for dataframes:\r\n\r\n\r\nmyDataFrame[1,2] #first row, second column\r\n\r\n\r\n[1] 0.01915408\r\n\r\nLet’s say you want to just look at the objects in column 1. There are four basic ways to do this (and probably more!)\r\n\r\n\r\nmyDataFrame[,1] # first column\r\nmyDataFrame[,'x'] # column named x\r\nmyDataFrame$x # column named x (most common)\r\nmyDataFrame[['x']] # column named x\r\n\r\n\r\n\r\nLists\r\nLast, but not least, lists are like file drawers cabinets where each object in the list (a drawer) can hold whatever it wants. Here’s an example:\r\n\r\n\r\nmyList <- vector('list',3) #this is a 3 object list, or a three drawer filed cabinet\r\nmyList\r\n\r\n\r\n[[1]]\r\nNULL\r\n\r\n[[2]]\r\nNULL\r\n\r\n[[3]]\r\nNULL\r\n\r\nLet’s add some stuff to the drawers:\r\n\r\n\r\nmyList[[1]] <- myDataFrame\r\nmyList[[2]] <- c('these','are','a','few', 'of', 'my', 'favorite', 'things')\r\nmyList[[3]] <- myMatrix\r\n\r\n\r\n\r\nThe first drawer now has our dataframe, the second a character vector, and the third a matrix. When you start working a lot with packages, you will see that packages often return objects to you in lists.\r\nNotice that you subset lists using the double brackets!\r\nIf you want to access a particular observation of a particular item in your list, you can do so. For example, let’s select the 2nd observation of the second element in the list:\r\n\r\n\r\nmyList[[3]][2,3]\r\n\r\n\r\n[1] 10\r\n\r\nTest your knowledge\r\nFollow THIS LINK to an interactive application to test the skills you learned in this lesson.\r\nAcknowledgements\r\nThis material (and much of the subsequent material) borrows from the work done by many before me. I’m especially grateful to Tyler Reny (Claremont Graduate University) and Justin Esarey (Wake Forest) for R resources and lessons.\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2021-11-16T19:51:16-08:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-10-31-external-resources-for-r-beginners/",
    "title": "External Resources for R Beginners",
    "description": "A collection of R resources from around the coding world.",
    "author": [
      {
        "name": "Derek Holliday",
        "url": {}
      }
    ],
    "date": "2021-10-31",
    "categories": [
      "resources"
    ],
    "contents": "\r\nAs mavens, we will provide you with custom resources and tutorials tailored to your needs as political science graduate students. However, much of learning R is experimenting with multiple learning styles and pulling from different sources, so we want to introduce you to a few external resources we consider to be (1) high in quality and (2) relevant to your particular needs. All of these resources are free (with the exception of one). No one person learns R in the same was as another, and that’s part of the fun!\r\nTraditional Courses\r\nMany people find the traditional university course structure to be good for personal accountability. There are a number of intro to R courses online that fit this description:\r\nJohns Hopkins Data Science: Foundations using R Specialization (via coursera).\r\nHarvard Statistics and R (via edX, Life Science focus but the earlier parts are still a good introduction)\r\ncodecademy’s Learn R (requires a subscription, but slightly more interactive than the other courses)\r\nVideos and Books\r\nA slightly more hands-off approach, these resources give you a number of videos and examples you can pick and choose between and explore at your own pace:\r\nR for Data Science aka “The Bible” written by Hadley Wickham and Garrett Grolemund (you’ll be seeing those names quite a bit), this is the definitive source for a “tidy” textbook introduction R for our purposes.\r\nRStudio Primers written by the folks over at RStudio themselves, so you get the best practices straight from the source.\r\nSICSS Boot Camp for an option in between a true course and pick-and-choose video options.\r\nInteractive Materials\r\nOne of the greatest pedagogical advancements for R in the past few years is the availability of within-IDE tutorials for R beginners. You can boot up RStudio, load a lesson via one of these packages, and just follow directions from there, so you are truly able to learn while doing:\r\nKosuke Imai’s Quantitative Social Science: An Introduction via swirl is especially good with the introductory courses, and best used as a prerequisite to the materials that follow.\r\nSeo-young Silvia Kim’s introduction to the tidyverse via swirl is an amazing resource for beginners looking to tidy their approach to R.\r\nIt is also worth noting that swirl itself has its own courses, but they haven’t been updated for a few years.\r\nTwitter\r\nTwitter provides a great place to keep up with the latest and greatest in R tutorials, packages, and advancements. There are too many amazing accounts to list here, but I will suggest following We are R-Ladies, Hadley Wickham, and Julia Silge as active R Twitter users.\r\nA Closing Word\r\nAs new acolytes of R, you should be familiar that there is an ongoing boycott of a certain provider of R resources that we have purposefully left off this list. You should be aware that the boycott exists and can learn about the reasons why here.\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-10-31-external-resources-for-r-beginners/rresources.png",
    "last_modified": "2021-10-31T20:02:49-07:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-10-25-welcome-post/",
    "title": "Welcome Post",
    "description": "Our first post!",
    "author": [
      {
        "name": "Derek Holliday",
        "url": {}
      }
    ],
    "date": "2021-10-25",
    "categories": [
      "announcements"
    ],
    "contents": "\r\nWelcome! This page is where posts will be indexed. These will include videos and guides created by mavens and lists of external resources we have found useful.\r\nHello World\r\n\r\n\r\n",
    "preview": "posts/2021-10-25-welcome-post/HelloWorld.svg",
    "last_modified": "2021-10-25T16:30:39-07:00",
    "input_file": {}
  }
]
